<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue实现国际化]]></title>
    <url>%2F2019%2F04%2F18%2Fvue%E5%AE%9E%E7%8E%B0%E5%9B%BD%E9%99%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言 最近的一个项目要给到国外的运营人员使用，所以需要实现国际化。这里就简单介绍一下v-cli实现国际化的原理和需要注意的问题 实现原理主要的实现原理是利用vue-i18n这个vue插件，配合官方文档可以帮助我们很方便的实现国际化。 实现步骤安装vue-i18n插件1npm install vue-i18n --save 使用vue-i18n12345678910111213141516171819202122232425262728293031//HTML&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; $t(&quot;message.hello&quot;) &#125;&#125;&lt;/p&gt;&lt;/div&gt;//JAVASCRIPTconst messages = &#123; en: &#123; message: &#123; hello: &apos;hello world&apos; &#125; &#125;, ja: &#123; message: &#123; hello: &apos;こんにちは、世界&apos; &#125; &#125;&#125;const i18n = new VueI18n(&#123; locale: &apos;ja&apos;, // set locale messages, // set locale messages&#125;)new Vue(&#123; i18n &#125;).$mount(&apos;#app&apos;)//OUTPUT&lt;div id=&quot;#app&quot;&gt; &lt;p&gt;こんにちは、世界&lt;/p&gt;&lt;/div&gt; 可以看到，我们在实例化Vue的时候，将i18n当做一个option传了进去。之后我们就可以在vue的组件里使用i18n了，使用方法： 在组件的template中，调用$t()方法 v-cli项目中使用 src目录下新增language目录，language目录下新增index.js,en.js, zh.js。en.js和zh.js就是我们的语言包。必须保证语言包的内容是一一对应的。然后我们在index.js中完成设置。 index.js加入代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import Vue from &apos;vue&apos;;import VueI18n from &apos;vue-i18n&apos;;import locale from &apos;element-ui/lib/locale&apos;;import enLocale from &apos;element-ui/lib/locale/lang/en&apos;;import zhLocale from &apos;element-ui/lib/locale/lang/zh-CN&apos;;import en from &apos;./en&apos;;import zh from &apos;./zh&apos;;Vue.use(VueI18n);const DEFAULT_LANG = &apos;zh&apos;;const LOCALE_KEY = &apos;localeLanguage&apos;;const locales = &#123; zh: &#123; ...zh, ...zhLocale, &#125;, en: &#123; ...en, ...enLocale, &#125;,&#125;const i18n = new VueI18n(&#123; locale: DEFAULT_LANG, messages: locales&#125;)export const setup = lang =&gt; &#123; if (lang === undefined) &#123; lang = window.localStorage.getItem(LOCALE_KEY); if (locales[lang] === undefined) &#123; lang = DEFAULT_LANG; &#125; &#125; window.localStorage.setItem(LOCALE_KEY, lang); Object.keys(locales).forEach(lang =&gt; &#123; document.body.classList.remove(`lang-$&#123;lang&#125;`); &#125;) document.body.classList.add(`lang-$&#123;lang&#125;`); document.body.setAttribute(&apos;lang&apos;, lang); Vue.config.lang = lang; i18n.locale = lang;&#125;setup();// window.i18n = i18n;locale.i18n((key, keypath) =&gt; i18n.t(key, keypath));export default i18n; 代码说明 因为是要配合element使用，所以必须也导入element的语言包并配置，具体更多实施方案请见element国际化。 为了记住用户的习惯我们这里在localStorage中加入语言的缓存。保存用户切换的语言。避免重新进入时语言需要切换。 英文文案大多相较过长，为了避免切换时页面适配出现问题我们可以在body上添加类名和自定义属性来适配不同语言。 main.js引入index.js 1234567891011import Vue from &apos;vue&apos;import App from &apos;./app.vue&apos;import store from &apos;./store&apos;import router from &apos;./router&apos;import i18n from &apos;./language/index&apos;;export const app = new Vue(&#123; i18n, router, store, render: h =&gt; h(App)&#125;).$mount(&quot;#app&quot;); 配置语言包 en.js 123456export default &#123; m: &#123; home: &apos;首页&apos;， music: &apos;音乐&apos; &#125;&#125; zh.js 123456export default &#123; m: &#123; home: &apos;home&apos;， music: &apos;music&apos; &#125;&#125; 至此，国际化的配置完成，我们就可以项目中使用了。 使用方式 作为普通文本使用 1&#123;&#123; $t(&apos;m.home&apos;) &#125;&#125; 配合属性使用 1:placeholder =&quot;$t(&apos;m.home&apos;)&quot; vue实例中使用 1this.$t(&apos;m.home&apos;)` 使用问题非vue实例的js中使用日常中我们会封装一些code.js和tools.js。这些js并不能使用vue实例上的方法。但是也需要国际化。这个时候我们只能单独导入i18n来使用。12import i18n from &apos;../language/index&apos;;i18n.t(&apos;m.home&apos;) 长文案加变量的翻译问题 在翻译这样一句话 我被用户 xxx 拉进一个群聊的时候。英文的翻译是I was dragged into a group chat by user xxx。xxx出现的地方不一致这个时候我们就不能简单的直接设置en.js和zh,js进行转换。 我们这里可以把这变量用一个字符替换，然后封装函数匹配变量进行替换 我被用户 %s 拉进一个群聊，I was dragged into a group chat by user %s 封装函数代码 1234567891011function tplParse(tpl, params) &#123; let counter = 0; if (params &amp;&amp; params.length &gt; 0) &#123; let match; while(match = tpl.match(/%s/)) &#123; tpl = tpl.slice(0, match.index) + params[counter] + tpl.slice(match.index + 2); counter ++; &#125; &#125; return tpl;&#125; 第一个参数是需要替换的文案，第二个参数就是替换的变量 切换语言的时候遍历的数据无法生效。在切换语言的时候我们会发现，router的index.js中的语言无法切换。这是因为data是一次性生产的，平常的写法只能是在 data 初始化的时候拿到这些被国际化的值，并不能响应变化。查阅文案给出的方案是需要遍历的数据通过computed重新计算一遍在返回。由于出现的地方较多这种方案实现起来太复杂。暂时的解决方案是切换语言的时候刷新页面。 结语到这里本篇文章就结束了，有问题的地方还请大家在评论区指出。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文字，英文溢出的处理方法]]></title>
    <url>%2F2019%2F03%2F29%2F%E8%A1%A8%E6%A0%BC%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D%E6%88%AA%E6%96%AD%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言平时做后台系统表格的时候总会遇到2种情况，一是表格中文字过长需要换行，也有客户希望表格高度一致，文字溢出隐藏显示…的要求。以往都是随便百度一下就写了。但是最近在做国际化的时候英文单词换行会出现单词被截断情况。借此我重新翻阅了下文档。本篇文章就介绍一下文字溢出的处理的方法和相关css属性。 相关属性对于non-CJK (non-CJK 指非中文/日文/韩文) 文本。这里以英文举例 word-break word-break: normal; word-break: break-all; word-break: keep-all; word-break: break-word; normal和keep-all：队尾放不下一个单词的时候，只能在半角空格或连字符处换行。否则超出的部分溢出显示。 break-all：队尾放不下一个单词的时候，先用单词前面的字母挤满这一行，多余的字母换行显示。 break-word：队尾放不下一个单词的时候，可以在半角空格或连字符处换行，没有半角空格或连字符处和break-all的规则保持一致。 word-wrap word-wrap: normal; word-wrap: break-word;对于non-CJK (non-CJK 指非中文/日文/韩文) 文本。这里以英文举例 normal：队尾放不下一个单词的时候，只能在半角空格或连字符处换行。否则超出的部分溢出显示。 break-word：队尾放不下一个单词的时候，可以在半角空格或连字符处换行，没有半角空格或连字符处先用单词前面的字母挤满这一行，多余的字母换行显示。 对于CJK (CJK 指中文/日文/韩文) 。这里以中文举例 以上的6个css属性除了word-break: keep-all其它5个属性效果一致。 word-break: keep-all：只能在半角空格或连字符处换行，没有半角空格或连字符处超出部分溢出显示。 其它5个属性：文字超出部分换行显示。 实现文字超过省略号结语这个方法可以用来实现禁止剪切和复制网页内容…]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>日常bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String笔记]]></title>
    <url>%2F2019%2F03%2F11%2FString%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言上一篇做了一下数组的总结，在总结的过程中重新巩固了对数组的方法的使用，很多以前没记住的细节也一一捡了起来，这一篇Sring笔记也是为了重新复习下String的相关定义和用法。 原生对象String1 JavaScript的原生对象String关于String作为原生对象和构造函数的区别，上一篇数组有过详细的解析。这里就直接开始分析这两种情况下的String的使用。 属性和方法使用length属性这里的length属性只是String对象本身的length属性，其值为1。 name属性name属性返回String对象名称。与length属性一样，其值为String。 fromCharCode()方法 一个参数： 要转换的数据 用法：返回使用指定的Unicode值序列创建的字符串。 12String.fromCharCode(98,99,100);// &quot;bcd&quot; 注意：作用于高位编码，返回简单的高位编码的字符串，例如阿拉伯数字等等。 fromCodePoint()方法。 一个参数： 要转换的数据 用法：返回使用指定的代码点序列创建的字符串。 1234String.fromCodePoint(0x2F804);// &quot;你&quot;String.fromCharCode(0x2F804);// &quot;&quot; 注意：String.fromCodePoint()是ES6的新方法，被用来返回一对低位编码，从而可以完全表示这些高位编码字符。 函数String创建规范字符串可以通过3个方式创建，字面量方式，String方法转化，以及String构造函数创建。12345678910111213141516let str = &quot;12&quot;;let str2 = String(&quot;13&quot;);console.log(typeof(str));console.log(typeof(str2));str.__proto__ === String.prototype;str2.__proto__ === String.prototype;// string// string// true// truelet str1 = new String(&quot;12&quot;);console.log(typeof(str1));str1.__proto__ === String.prototype;// object// true 字面量方式创建的字符串和String方法转化的字符串都是基本字符串。这些基本字符串没有属性和方法。而通过String构造函数创建的实例对象都是字符串对象，它继承String原型的上的属性和方法。 当基本字符串需要调用一个字符串对象才有的方法或者查询值的时候(基本字符串是没有这些方法的)，JavaScript会自动将基本字符串转化为字符串对象并且调用相应的方法或者执行查询。 实例方法（es5）通过构造函数new String创建的实例对象，它们的__proto__属性都是指向了String构造函数的原型对象，就继承了原型对象上的属性和方法。String.prototype. charAt()方法 一个参数： index 字符串的索引，取值为整数。(0~length-1)。 传入非数字或者不传则默认取索引为0的字符。 传入的数值大于取值范围(0~length-1)，返回空字符串。 用法：方法从一个字符串中返回指定索引的字符。 1234567891011121314let str = &quot;123&quot;;console.log(str.charAt(0));console.log(str.charAt(1));console.log(str.charAt(2));console.log(str.charAt());console.log(str.charAt(&quot;0&quot;));console.log(str.charAt(5));// 打印结果12311&quot;&quot; concat()方法 多个参数： string1， string2... 和原字符串连接的多个字符串。 用法：方法将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。 123456789101112131415let str1 = &quot;hello&quot;;let str2 = &quot;world&quot;;let str3 = str1 + str2;let str4 = str1.concat(str2);console.log(str1);console.log(str3);console.log(str4);let str5 = `$&#123;str1&#125;：$&#123;str2&#125;`console.log(str5);// 打印结果&quot;hello&quot;&quot;helloworld&quot;&quot;helloworld&quot;&quot;hello：world&quot; 注意： 性能上字符串拼接性能高于使用concat方法。 ES6的模板字符串拼接方便与其他未声明的字符串拼接。 indexOf()方法 两个个参数： string 指定查询的字符串。 index 表示调用该方法的字符串中开始查找的位置，取值为整数，默认值为0。 查找的值是非空字符串。 index &lt; 0 与传入默认值0返回结果一致。 如果index &gt;= str.length，则该方法返回-1。 查找的值是空字符串。 index &lt;= 0 时返回0。 0 &lt; index &lt;= str.length时返回index的值。 index &gt; str.length时返回str.length。 用法：方法返回调用String对象中第一次出现的指定值的索引，如果未找到该值，则返回-1。 12345678910111213141516171819let str = &quot;this is a question&quot;;let findStr = &quot;question&quot;;let emptyStr = &quot;&quot;;console.log(str.indexOf(findStr));console.log(str.indexOf(findStr, -1));console.log(str.indexOf(findStr, 20));console.log(str.indexOf(&quot;answer&quot;));console.log(str.indexOf(emptyStr, -1));console.log(str.indexOf(emptyStr, 15));console.log(str.indexOf(emptyStr, 20));// 打印结果1010-1-101518 lastIndexOf()方法 两个个参数： string 指定查询的字符串。 index 表示调用该方法的字符串中开始查找的位置，取值为整数，默认值为str.length。 查找的值是非空字符串 index &lt; 0 则index = 0。 如果 index &gt; str.length，则index = str.length。 查找的值是空字符串 index &lt;= 0 时返回0。 0 &lt; index &lt;= str.length时返回index的值。 index &gt; str.length时返回str.length。 用法：方法返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回-1。从该字符串的后面向前查找，从index处开始。 12345678910111213141516171819let str = &quot;this is a question&quot;;let findStr = &quot;question&quot;;let emptyStr = &quot;&quot;;console.log(str.lastIndexOf(findStr));console.log(str.lastIndexOf(findStr, 20));console.log(str.lastIndexOf(findStr, -1));console.log(str.lastIndexOf(&quot;answer&quot;));console.log(str.lastIndexOf(emptyStr, -1));console.log(str.lastIndexOf(emptyStr, 15));console.log(str.lastIndexOf(emptyStr, 20));// 打印结果1010-1-101518 slice()方法 两个个参数： beginIndex 开始提取字符串的索引位置，取值为整数。 如果为负数，则beginIndex = str.length + beginIndex; 如果省略该参数，beginIndex = 0。 endIndex 结束提取字符串的索引位置，取值为整数。 如果endIndex &lt; 0，则endIndex= str.length + endIndex; 如果endIndex &gt; str.length - 1，slice会一直提取到字符串末尾。 如果省略该参数，slice会一直提取到字符串末尾 用法：方法提取一个字符串的一部分，并返回一新的字符串。提取的新字符串包括beginIndex但不包括endIndex。 12345678910let str = &quot;xiaohei like play basketball&quot;;console.log(str.slice());console.log(str.slice(0, 50));console.log(str.slice(-3));console.log(str.slice(0, -9));// 打印结果&quot;xiaohei like play basketball&quot;&quot;xiaohei like play basketball&quot;&quot;all&quot;&quot;xiaohei like play b&quot; split()方法 两个参数： separator 指定表示每个拆分应发生的点的字符串。 如果省略，会返回有含有整个字符串元素的数组; 如果分隔符为空字符串，则将原字符串中每个字符的数组形式返回。 limitNumber 指定分割后返回数组的元素个数，取值为整数。 如果limitNumber&lt; 0，则返回全部被分割的元素组成的数组; 如果limitNumber大于当前被分割的元素个数，则返回全部被分割的元素组成的数组。 如果limitNumber小于当前被分割的元素个数，则返回limitNumber个数的元素组成的数组。 如果省略该参数，则返回全部被分割的元素组成的数组。 用法：方法使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。不改变原有字符串。 1234567891011121314151617181920let str = &quot;asd,12,2,321,21&quot;console.log(str.split(&quot;,&quot;, 0));console.log(str.split(&quot;,&quot;, -1));console.log(str.split(&quot;,&quot;));console.log(str.split(&quot;,&quot;, 3));console.log(str.split(&quot;,&quot;, 6));let str1 = &quot;today is sunday&quot;;console.log(str1.split());console.log(str1.split(&quot;&quot;));//打印结果[][&quot;asd&quot;, &quot;12&quot;, &quot;2&quot;, &quot;321&quot;, &quot;21&quot;][&quot;asd&quot;, &quot;12&quot;, &quot;2&quot;, &quot;321&quot;, &quot;21&quot;][&quot;asd&quot;, &quot;12&quot;, &quot;2&quot;][&quot;asd&quot;, &quot;12&quot;, &quot;2&quot;, &quot;321&quot;, &quot;21&quot;][&quot;today is sunday&quot;][&quot;t&quot;, &quot;o&quot;, &quot;d&quot;, &quot;a&quot;, &quot;y&quot;, &quot; &quot;, &quot;i&quot;, &quot;s&quot;, &quot; &quot;, &quot;s&quot;, &quot;u&quot;, &quot;n&quot;, &quot;d&quot;, &quot;a&quot;, &quot;y&quot;] substring()方法 两个参数： startIndex 截取字符串开始的索引，为一个整数。 startIndex = endIndex，返回一个空字符串。 startIndex &gt; endIndex则startIndex = endIndex而endIndex = startIndex。 startIndex &lt; 0或者startIndex = NaN, 则startIndex = 0。 startIndex &gt; str.length - 1 则startIndex = str.length - 1。 endIndex 截取字符串结束的索引，为一个整数。 endIndex &lt; 0或者endIndex=NaN, 则endIndex=0。 endIndex &gt;str.length - 1则endIndex= str.length - 1。 用法：方法返回一个字符串在开始索引到结束索引之间字符串。不改变原有字符串。 12345678910111213let str = &quot;qwertydf&quot;;console.log(str.substring());console.log(str.substring(1, 1));console.log(str.substring(-1, 3));console.log(str.substring(-1, 20));console.log(str.substring(6, 0));// 打印结果&quot;qwertydf&quot;&quot;&quot;&quot;qwe&quot;&quot;qwertydf&quot;&quot;qwerty&quot; toUpperCase()方法，toLocaleUpperCase()方法toUpperCase()方法将调用该方法字符串值转换为大写形式，并返回。 toLocaleUpperCase()方法使用本地化locale-specific的大小写映射规则将输入的字符串转化成大写形式并返回结果字符串。 参数：无。 用法：两个方法绝大多数情况下返回结果一致，对于一些特殊的语言会返回不同，（日常使用中没啥区别）。都不会改变原来字符串。 123let str = &quot;helloworld, HI&quot;;str.toLocaleUpperCase(); // HELLOWORLD, HIstr.toUpperCase(); // HELLOWORLD, HI toLowerCase()方法，toLocaleLowerCase()方法toLowerCase()方法将调用该方法的字符串值转换为小写形式，并返回。 toLocaleLowerCase()方法使用本地化locale-specific的大小写映射规则将输入的字符串转化成小写形式并返回结果字符串。 参数：无。 用法：两个方法绝大多数情况下返回结果一致，对于一些特殊的语言会返回不同，（日常使用中没啥区别）。都不会改变原来字符串。 123let str = &quot;helloworld, HI&quot;;str.toLocaleLowerCase(); // helloworld, histr.toLowerCase(); // helloworld, hi valueOf()方法，toString()方法valueOf()：字符串或者字符串对象调用该方法返回的该字符串的基本字符串格式。 toString()：字符串或者字符串对象调用该方法返回的该字符串的基本字符串格式。 参数：无。 用法：上文中提到了字符串的两个基本格式，基本字符串和字符串对象，而基本字符串在使用实例方法时，JavaScript会把它转化成字符串对象后再调用方法。所以无论是基本字符串还是字符串对象调用这两个方法，本质上是没有区别的。valueOf()方法通常在JavaScript内部被调用，而不是在代码里显示调用。 12345678910let baseStr = &quot;baseString&quot;;let objStr = new String(&quot;objectString&quot;);console.log(baseStr.toString());console.log(objStr);console.log(objStr.valueOf());// 打印结果&quot;baseString&quot;String &#123;0: &quot;o&quot;, 1: &quot;b&quot;, 2: &quot;j&quot;, 3: &quot;e&quot;, 4: &quot;c&quot;, 5: &quot;t&quot;, 6: &quot;S&quot;, 7: &quot;t&quot;, 8: &quot;r&quot;, 9: &quot;i&quot;, 10: &quot;n&quot;, 11: &quot;g&quot;&#125;&quot;objectString&quot; trim()方法 参数：无。 用法：方法会从一个字符串的两端删除空白字符。方法并不影响原字符串本身。 123let str = &quot;test&quot;;console.log(str.trim()); // testconsole.log(str); // test 实例方法（ES6）通过构造函数new String创建的实例对象，它们的__proto__属性都是指向了String构造函数的原型对象，就继承了原型对象上的属性和方法。String.prototype. includes()方法 参数：两个参数。 string 指定查询的字符串。 index 开始查询的位置，取值为整数。 取值不正确或不填默认从0开始。 用法：方法用于判断一个字符串是否包含在另一个字符串中，根据情况返回true或false。 1234567891011let str = &quot;hello world&quot;;let str1 = &quot;world&quot;;console.log(str.includes(str, 0));console.log(str.includes(str1, 6));console.log(str.includes(str1, 20));console.log(str.includes(str1, &quot;ads&quot;));// 打印结果truetruefalsetrue startWith()方法 参数：两个参数。 string 指定查询的字符串。 index 开始查询的位置，取值为整数。 取值不正确或不填默认从0开始。 用法：方法用来判断当前字符串是否是以另外一个给定的子字符串开头的，根据判断结果返回true或false。 12345678let str = &quot;object is not found&quot;;console.log(str.startsWith(&quot;object&quot;, 1));console.log(str.startsWith(&quot;object&quot;));console.log(str.startsWith(&quot;object&quot;, &quot;sadas&quot;));// 打印结果falsetruetrue endWith()方法 参数：两个参数。 string 指定查询的字符串。 index 开始查询的位置，取值为整数。 取值不正确或者不填默认字符串末尾是否已要查找的字符串结尾。 如果传值正确，则表示从str.length-index处往前的字符串是否以要查找的字符串结尾。 用法：方法用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回true或false。 12345678910let str = &quot;object,String&quot;;console.log(str.endsWith(&quot;object&quot;)); // falseconsole.log(str.endsWith(&quot;String&quot;)); // true// 从str.length - index往前的字符串// 从7索引位置开始前面的字符串是否包含objectconsole.log(str.endsWith(&quot;object&quot;, 6)); // true// 从6索引位置开始前面的字符串是否包含objectconsole.log(str.endsWith(&quot;object&quot;, 7)); // false padStart()方法， padEnd()方法 参数：两个参数。 length 补全字符串的长度，取值为整数。 如果原字符串长度大于补全长度，则返回原字符串。 string 用来补全的字符串。 如果不填则以空字符串补全。 如果补全的字符串长度与原字符串长度相加大于了补全长度参数，则会截取大于补全长度的多余的补全字符串。 用法：方法用来在字符串头部/尾部补全不够指定长度的字符串，返回新的字符串，不改变原来字符串。 1234567891011121314151617181920212223242526272829let str = &quot;1&quot;;console.log(str.padStart(3));console.log(str.padEnd(3));console.log(str.padStart(3, &quot;2&quot;));console.log(str.padEnd(3, &quot;2&quot;));let str1 = &quot;abcdefg&quot;;console.log(str1.padStart(10, &quot;hijklm&quot;));console.log(str1.padEnd(10, &quot;hijklm&quot;));let str2 = &quot;09-12&quot;console.log(str2.padStart(10, &quot;YYYY-MM-DD&quot;));let str3 = &quot;abc&quot;;console.log(str3.padStart(2));console.log(str3.padEnd(2, &quot;2222&quot;));// 打印结果&quot; 1&quot;&quot;1 &quot;&quot;221&quot;&quot;122&quot;&quot;hijabcdefg&quot;&quot;abcdefghij&quot;&quot;YYYY-09-12&quot;&quot;abc&quot;&quot;abc&quot; repeat()方法 参数：一个参数。 number 指定重复的次数，取值为整数。 取值为0表示重复0次，返回空字符串。 取值为NaN或者(-1,0]则number = 0。 字符串转化成数字。 小于等于-1的数或者无限数都会报错。 小数直接取整。 用法：方法用来把原字符串重复n次，返回新字符串。 123456789101112131415161718192021222324let str = &quot;a&quot;;console.log(str.repeat(0));console.log(str.repeat(2));console.log(str.repeat(2.9));console.log(str.repeat(&quot;asd&quot;));console.log(str.repeat(-0.9));console.log(str.repeat(&quot;2&quot;));console.log(str.repeat(-1));console.log(str.repeat(Infinity));// 打印结果&quot;&quot;&quot;aa&quot;&quot;aa&quot;&quot;&quot;&quot;&quot;&quot;aaa&quot;&quot;Uncaught RangeError: Invalid count value&quot;&quot;Uncaught RangeError: Invalid count value&quot; 由于正则这块忘得差不多了，所以String与正则相关的方法会在后续完成正则的复习后再加上…]]></content>
      <categories>
        <category>Javascript原生对象</category>
      </categories>
      <tags>
        <tag>Javascript原生对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array笔记]]></title>
    <url>%2F2019%2F03%2F05%2FArray%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言数组是我们平时编码中必不可少的一个重要，无论是数据的处理还是数据的传递，它都起到了至关重要的作用。无论是老版的JavaScript还是ES6都提供了大量的方法让我们来对数组进行处理。本文主要介绍Array对象的本质和它的相关属性，方法。 Array原型图原型链示意图 分两个方向来分析 原生对象Array作为JavaScript的原生对象Array 属性和方法 按f12打开控制台输入Array.你会发现侧边出现了很长的一串的属性和方法的补全提示，这些属性和方法到底哪些是可用的又有哪些是Array对象本身的呢？我们可以试验一下。 1234567891011121314151617console.log(Array.length);console.log(Array.name);console.log(Array.from);console.log(Array.isArray);console.log(Array.of);console.log(Array.apply);console.log(Array.bind);console.log(Array.constructor);console.log(Array.toString);console.log(Array.hasOwnProperty);console.log(Array.isPrototypeOf);console.log(Array.toLocaleString);console.log(Array.valueOf);console.log(Array.arguments);console.log(Array.call);console.log(Array.caller); 打印结果 除了最后的3个属性报错其他的属性或方法全部被打印出来，但是这些不一定就是Array的本身的属性和方法。首先Array可以作为函数实例对象实际上可以看做是通过new Function()创建的，所以它继承了Function原型对象上的属性和方法，而Function.prototype作为对象是可以继承Object原型对象上的属性和方法。所以Array也继承了Object原型对象上的属性和方法。 我们可以通过Object的hasOwnProperty方法来判断哪些才是真正的属于Array对象的属性和方法。 123456789101112131415161718192021222324252627console.log(Array.hasOwnProperty(&quot;length&quot;));console.log(Array.hasOwnProperty(&quot;name&quot;));console.log(Array.hasOwnProperty(&quot;from&quot;));console.log(Array.hasOwnProperty(&quot;isArray&quot;));console.log(Array.hasOwnProperty(&quot;of&quot;));console.log(Array.hasOwnProperty(&quot;apply&quot;));console.log(Array.hasOwnProperty(&quot;bind&quot;));console.log(Array.hasOwnProperty(&quot;constructor&quot;));console.log(Array.hasOwnProperty(&quot;toString&quot;));console.log(Array.hasOwnProperty(&quot;hasOwnProperty&quot;));console.log(Array.hasOwnProperty(&quot;isPrototypeOf&quot;));console.log(Array.hasOwnProperty(&quot;toLocaleString&quot;));console.log(Array.hasOwnProperty(&quot;valueOf&quot;));//打印结果truetruetruetruetruefalsefalsefalsefalsefalsefalsefalsefalse 通过上面的分析我们知道了Array作为对象其实只拥有length，name两个属性和form，isArray，of这3个方法。 注意：这里还有几个继承的方法和属性我没有一一列举出来更多属性可见详情[Array][4] 属性和方法使用length属性返回Array对象的长度。这里的length属性只是Array本身的length属性，其值为1。 name属性返回Array对象名称。与length属性一样，其值为Array。 form方法转换其它类型的数据并返回一个新的数组。 参数1：要转换的数据 用法： 将类数组对象转换为真正数组 123456789let fakeArray = &#123; 0: &quot;csz&quot;, 1: &quot;women&quot;, 2: &quot;21&quot;, 3: [&quot;say&quot;,&quot;sleep&quot;,&quot;drink&quot;], &apos;length&apos;: 4&#125;console.log(Array.from(fakeArray))// [&quot;csz&quot;, &quot;women&quot;, &quot;21&quot;, [&quot;say&quot;,&quot;sleep&quot;,&quot;drink&quot;]] 注意：要将一个类数组对象转换为一个真正的数组，必须具备以下条件： 该类数组对象必须具有length属性，用于指定数组的长度。如果没有length属性，那么转换后的数组是一个空数组。 该类数组对象的属性名必须为数值型或字符串型的数字。如果不是转成的数组的值全是undefined。 用法：将Set结构的数据转换为真正的数组： 1234let arr = [1,2,3,4,5,5,6]let set = new Set(arr);console.log(Array.from(set)); // [1,2,3,4,5,6] 用法：将字符串转换为数组：返回分割字符串形成的数组。 123let str = &apos;foo&apos;;console.log(Array.from(str));// [&quot;f&quot;,&quot;o&quot;,&quot;o&quot;] 用法：Array.from参数是一个真正的数组：返回原数组。 12console.log(Array.from([1,2,3,4,5]))// [1,2,3,4,5] 参数2：回调函数 用法： 123let arr = [1, 2, 3, 4, 5];console.log(Array.from(arr, item =&gt; item + 1));// [2,3,4,5,6]; isArray方法用于判断一个对象是否为数组。 参数1：要判断的数据 用法： 12345678910let arr = [1,2,3];let str = &quot;123&quot;;let num = 123;Array.isArray(arr);Array.isArray(str);Array.isArray(num);// 打印结果truefalsefalse of方法用于创建一个新的数组。 参数1：创建的数据的元素 用法： 1234567let arr = Array.of(1);let arr2 = Array.of(2);let arr3 = Array.of(1,2,3,4);//[1][5][1,2,3,4] 注意：form和of都是ES6新增的方法。 函数Array作为构造函数调用或者普通函数调用。 规范当数组作为函数调用而不是构造函数调用时，它会创建并初始化一个新的数组对象。因此当Array(...)和new Array(...)接收同样的参数时，它们是相同的。1234let arr = Array(1,3);// [1,3];let arrs = new Array(1,3);// [1,3]; 传参 传入多个数值或者多个其它类型的数据的时候，直接以【，】分割这些数据形成一个新的数组。 1234let arrStr = new Array(&quot;1&quot;, &quot;2&quot;);//[&quot;1&quot;,&quot;2&quot;]let arrObj = new Array(&#123;name: &quot;csz&quot;&#125;, &#123;&quot;age&quot;: 12&#125;);//[&#123;name: &quot;csz&quot;&#125;, &#123;age: 12&#125;] 传入一个0到232-1之间的整数，会把它识别为创建的数组的长度，会创建一个这个以这个整数位长度，每一项都是undefined的数组。 123let arr = new Array(3);console.log(arr[0], arr[1], arr.length);// undefined, undefined, 3 ES6新增的of方法没有第二种传参方式。 实例方法（ES5）不管是通过字面量还是new Array亦或者是Array.of()创建的实例对象，它们的__proto__属性都是指向了Array的原型对象，就继承了原型对象上的属性和方法。Array.prototype. forEach()方法 两个参数： callback接受3个参数。 currentValue，数组中正在处理的当前元素。 index，数组中正在处理的当前元素的索引。 array，forEach方法被调用的数组。 thisArg 执行callback函数时使用的this值。 如果thisArg参数有值，则每次callback函数被调用的时候，this都会指向thisArg参数上的这个对象。如果省略了thisArg参数,或者赋值为null或undefined，则this指向全局对象。 用法：数组调用该方法，每一个元素执行callback一次。 1234567891011let arr = [1, 2, 3];arr.forEach(function (v, i, arr) &#123; console.log(v); arr.push(1);&#125;);console.log(arr);// 打印结果123[1,2,3,1,1,1] shift() 参数：无。 用法：方法从数组中删除第一个元素，并返回该元素的值。此方法更改原有数组。 123let arr = [1, 2, 3];console.log(arr.shift()); // 1console.log(arr); // [2,3] pop() 参数：无。 用法：方法从数组中删除最后一个元素，并返回该元素的值。此方法更改原有数组。 123let arr = [1, 2, 3];console.log(arr.pop()); // 3console.log(arr); // [1,2] unshift() 一个参数 elementN要添加到数组开头的元素。 用法：方法将一个或多个元素添加到数组的开头，并返回该数组的新长度。此方法更改原有数组。 123let arr = [1, 2, 3];console.log(arr.unshift(4, 5)); // 5console.log(arr); // [4,5,1,2,3] push() 一个参数 elementN要添加到数组开头的元素。 用法：方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。此方法更改原有数组。 123let arr = [1, 2, 3];console.log(arr.push(4, 5)); // 5console.log(arr); // [1,2,3,4,5] splice() 三个参数 start​ 指定修改的开始位置（从0计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位（从-1计数）；如果负数的绝对值大于数组的长度，则表示开始位置为第0位。 deleteCount 整数，表示要移除的数组元素的个数。 如果deleteCount是0或者负数，则不移除元素。这种情况下，至少应添加一个新元素。 如果deleteCount大于start之后的元素的总数，则从start后面的元素都将被删除（含第start位）。 如果deleteCount被省略，则其相当于(arr.length - start)。 item1, item2, ... 要添加进数组的元素,从start位置开始。如果不指定，则splice()将只删除数组元素。 用法：方法通过删除现有元素和/或添加新元素来修改数组,并以数组返回原数组中被修改的元素。此方法更改原有数组。 123456789101112131415161718192021222324let arr = [1, 2, 3, 4, 5];// start超过数组长度，且没有添加新的元素console.log(arr.splice(5)); //[]console.log(arr); //[1,2,3,4,5]// start不超过数组长度，且没有添加新的元素let arr1 = [1, 2, 3, 4, 5];console.log(arr1.splice(0, 2)); //[1,2]console.log(arr1); //[3,4,5]// start不超过数组长度，删除个数为0或者负数，添加新的元素let arr2 = [1, 2, 3, 4, 5];console.log(arr2.splice(0, 0, 1)); // []console.log(arr2); // [1,1,2,3,4,5]// start为负数且负数绝对值不超过数据长度，添加新的元素let arr3 = [1, 2, 3, 4, 5];console.log(arr3.splice(-3, 1, &quot;a&quot;)); //[3]console.log(arr3); //[1,2,&quot;a&quot;,4,5]// start为负数且负数绝对值超过数据长度，添加新的元素let arr4 = [1, 2, 3, 4, 5];console.log(arr4.splice(-6, 1, &quot;a&quot;)); //[3]console.log(arr4); //[&quot;a&quot;,2,3,4,5] slice() 两个参数： start​ 指定截取的开始位置（从0计数）。如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取。 省略就从0开始截取。 没有end就从开始位置截取，剩下的所有数组中的元素。 end 在该索引处结束提取原数组元素（从0开始）。 slice会提取原数组中索引从begin到end的所有元素（包含begin，但不包含end）。 用法：方法通起止索引截取数组中的元素，返回一个新的数组对象。原始数组不会被改变。 1234567891011121314let arr = [1, 2, 3, 4, 5];// start为正数，没有endconsole.log(arr.slice(1)); //[2,3,4,5]console.log(arr); //[1,2,3,4,5]let arr1 = [1, 2, 3, 4, 5];// start为正数，有endconsole.log(arr1.slice(1, 3)); //[2,3]console.log(arr1); //[1,2,3,4,5]let arr2 = [1, 2, 3, 4, 5];// 两个参数都是负数console.log(arr2.slice(-3, -1)); //[3,4]console.log(arr2); //[1,2,3,4,5] join()方法 一个参数 eparator 指定一个字符串来分隔数组的每个元素。 默认为,。 如果separator是空字符串&quot;&quot;，则所有元素之间都没有任何字符。 用法：将一个数组的所有元素按指定分隔符连接成一个字符串并返回这个字符串，不改变原数组。 1234let arr = [1, 3, 4];console.log(arr.join(&quot;&quot;)); // &quot;134&quot;console.log(arr.join(&quot;-&quot;)); // &quot;1-3-4&quot;// &quot;1&quot;; reverse() 方法 参数：无。 用法：方法将数组中元素的位置颠倒。改变原数组。 123let arr = [1,2,3,4,5];console.log(arr.reverse()); // [5, 4, 3, 2, 1]console.log(arr) // [5, 4, 3, 2, 1] concat()方法 参数：无。 用法：用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。 1234let arr = [1, 3, 4];let arr1 = [1, 2, &quot;a&quot;];console.log(arr.concat(arr1));// [1,3,4,1,2,&quot;a&quot;]; indexOf()方法 两个参数： searchElement 要查找的元素。 fromIndex 开始查找的位置。默认为0 -1代表数组中的最后一个元素，依次为起点往前查找。 用法：返回在数组中可以找到给定元素的第一个索引，如果不存在，则返回-1。 123let arr = [1, 2, 3];console.log(arr.indexOf(1)); // 0console.log(arr.indexOf(5)); // -1 lastIndexOf()方法 两个参数： searchElement要查找的元素。 fromIndex 从此位置开始逆向查找。默认为数组的长度减1，即整个数组都被查找。 如果该值大于或等于数组的长度，则整个数组会被查找。如果为负值，将其视为从数组末尾向前的偏移。 即使该值为负，数组仍然会被从后向前查找。如果该值为负时，其绝对值大于数组长度，则方法返回-1，即数组不会被查找。 用法：返回指定元素在数组中的最后一个的索引，如果不存在则返回-1。从数组的后面向前查找，从传参的索引处开始。 123let arr = [1, 2, 3, 1];console.log(arr.lastIndexOf(1, 0)); // 3console.log(arr.lastIndexOf(1, 2)); // 0 toString()方法 参数：无。 用法：返回一个数组元素组成的字符串，以逗号分隔。不改变原数组。 123let arr = [1, 2, 3];console.log(arr.toString()); // &quot;1,2,3&quot;console.log(arr); // [1, 2, 3] map()方法 两个参数： callback接受3个参数。 currentValue，数组中正在处理的当前元素。 index，数组中正在处理的当前元素的索引。 array，map方法被调用的数组。 thisArg 执行callback函数时使用的this值。 如果thisArg参数有值，则每次callback函数被调用的时候，this都会指向thisArg参数上的这个对象。如果省略了thisArg参数,或者赋值为null或undefined，则this指向全局对象。 用法：数组调用该方法，callback会循环遍历数组一次，最后返回一个每一次循环遍历处理后的结果组成的新数组。不会改变原有数组。 12345678910111213141516171819let obj = &#123; name: &apos;csz&apos;, say: function () &#123; console.log(this.name); &#125;&#125;let arr = [1, 2];let map1 = arr.map(function (value, index, array) &#123; console.log(value, index, array); this.say(); return value = value + 2;&#125;, obj);console.log(map1, arr);// 打印结果1 0 [1, 2]csz2 1 [1, 2]csz[3, 4] [1, 2] 因为箭头函数内的this指向是保持不变的，所以当要使用thisArg参数时，不要使用箭头函数。 every() 两个参数： callback用来测试每个元素的函数，接受3个参数。 currentValue，数组中正在处理的当前元素。 index，数组中正在处理的当前元素的索引。 array，every方法被调用的数组。 遍历数组的每一个元素执行callback，只要有一个元素在执行callback的时候return false，every方法停止执行返回false。 hisArg执行callback时使用的this值。（使用方法用map()一致） 用法：方法测试数组的所有元素是否都通过了指定函数的测试。全部通过返回true, 否则返回false。 1234567891011let arr = [1, 3, 5, 7, 9, 10];let arr1 = [1, 3, 5, 7];console.log(arr.every((v, i, array) =&gt; &#123; return v % 2 !== 0;&#125;));console.log(arr1.every((v, i, array) =&gt; &#123; return v % 2 !== 0;&#125;));// 打印结果falsetrue some() 两个参数： callback用来测试每个元素的函数，接受3个参数。 currentValue，数组中正在处理的当前元素。 index，数组中正在处理的当前元素的索引。 array，every方法被调用的数组。 遍历数组的每一个元素执行callback，只要有一个元素在执行callback的时候return true，every方法停止执行返回true。 thisArg执行callback时使用的this值。（使用方法用map()一致） 用法：方法测试数组中的某些元素是否通过由提供的函数实现的测试。有一个通过返回true, 全部不通过返回false。 12345let arr = [1, 3, 5, 7, 9, 21, 2, 4, 6];console.log(arr.some((v, i, array) =&gt; &#123; return v &gt; 10;&#125;));// true filter() 两个参数： callback用来测试每个元素的函数，接受3个参数。 currentValue，数组中正在处理的当前元素。 index，数组中正在处理的当前元素的索引。 array，filter方法被调用的数组。 遍历数组的每一个元素执行callback，把满足条件的元素返回最后集合组成一个新的数组。 thisArg执行callback时使用的this值。（使用方法用map()一致） 方法：方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 123456let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];let newArr = arr.filter((v, i, array) =&gt; &#123; return v % 2 === 0;&#125;);console.log(newArr);// [2,4,6,8] 实例方法（ES6）不管是通过字面量还是new Array亦或者是Array.of()创建的实例对象，它们的__proto__属性都是指向了Array的原型对象，就继承了原型对象上的属性和方法。Array.prototype. includes()方法 两个参数： searchElement需要查找的元素值。- fromIndex从该索引处开始查找searchElement。如果为负值，则按升序从array.length - fromIndex的索引开始搜索。默认为0。 用法：用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回true，否则返回false。 123let arr = [1, 2, 3];console.log(arr.includes(1)); // trueconsole.log(arr.includes(5)); // false find()方法 两个参数： callback用来测试每个元素的函数，接受3个参数。 currentValue，数组中正在处理的当前元素。 index，数组中正在处理的当前元素的索引。 array，find方法被调用的数组。 遍历数组的每一个元素执行callback，返回第一个满足条件的元素。 thisArg执行callback时使用的this值。（使用方法用map()一致） 用法：方法返回数组中满足提供的测试函数的第一个元素的值。否则返回undefined。 123456let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];let newArr = arr.find((v, i, array) =&gt; &#123; return v &gt; 5;&#125;);console.log(newArr);// 6 findIndex()方法 两个参数： callback用来测试每个元素的函数，接受3个参数。 currentValue，数组中正在处理的当前元素。 index，数组中正在处理的当前元素的索引。 array，findIndex方法被调用的数组。 遍历数组的每一个元素执行callback，返回第一个满足条件的元素的索引。 thisArg执行callback时使用的this值。（使用方法用map()一致） 用法：方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。 123456let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];let newArr = arr.findIndex((v, i, array) =&gt; &#123; return v &gt; 5;&#125;);console.log(newArr);// 5 fill()方法方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。改变原数组。 三个参数： start`用来填充数组元素的值。 start起始索引，默认值为0。 end终止索引，默认值为this.length。 用法 1234let arr = [1, 2, 3, 4, 5, 6];arr.fill(&quot;csz&quot;, 1, 4);console.log(arr);// [1, &quot;csz&quot;, &quot;csz&quot;, &quot;csz&quot;, 5, 6] 还有几个方法相关介绍我还没有理的很清楚，这里先不贴了。等后续会加上…]]></content>
      <categories>
        <category>Javascript原生对象</category>
      </categories>
      <tags>
        <tag>Javascript原生对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next主题优化]]></title>
    <url>%2F2019%2F03%2F05%2Fnext%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言最近博客更新了一下主题，由之前的yilia主题更新成集成功能更齐全的next。借此也把搭建博客和优化主题的过程记录一下。 搭建博客搭建环境 Node.js下载安装: https://nodejs.org/en/download/ git下载安装：https://git-scm.com/downloads hexo下载安装，搭建博客： 在桌面新建test目录，进入test目录右键选择git Bash Here在命令行界面初始化hexo（这里以test文件夹为例，文中后续都是以test文件夹作为根目录） 1$ hexo init 更新下载依赖包 1$ hexo install 启动本地服务 1$ hexo s 浏览器访问：http://localhost:4000可以看到博客已经搭建在本地。 部署到github上 创建github账号：https://github.com。（注册的邮箱一定要验证） 新建一个名为&lt;github用户名&gt;.github.io的仓库，比如说，如果你的github用户名是mygithub，那么你就新建mygithub.github.io的仓库。 安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可： 1$ npm install hexo-deployer-git --save 配置ssh 检查是否有ssh 1$ cd ~/. ssh #检查本机已存在的ssh密钥（No such file or directory 说明你是第一次使用git。） 生成ssh 1$ ssh-keygen -t rsa -C &quot;邮件地址&quot;（注册github时的邮箱） 然后连续3次回车，复制密钥文件内容（路径形如C:\Users\Administrator\.ssh\id_rsa.pub），粘贴到New SSH Key即可。打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： 测试是否成功配置ssh 1$ ssh -T git@github.com 提示 Are you sure you want to continue connecting (yes/no)?，输入yes返回 “You’ve successfully authenticated” 即成功： 修改_config.yml（在test目录下）。文件末尾添加下面代码： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回 INFO Deploy done: git 即成功推送： 1$ hexo d -g 至此，Hexo博客已经搭建在GithubPages, 域名为https://&lt;Github账号名称&gt;.github.io 主题选择和优化主题选择 这里我选择的是next主题，在/test目录下载主题文件 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 修改/test目录下的_config.yml文件，更改theme字段，为主题文件夹的名称 1$ theme: next 主题基本配置设置 语言 修改/test目录下的_config.yml文件，选择语言1language: zh-Hans（默认为英文，zh-Hans为中文简体） 设置 作者昵称 /test目录下的_config.yml文件，设置author为你的昵称。1author : &lt;你的昵称&gt; 设置 站点描述 修改/test目录下的_config.yml文件，设置description字段为你的站点描述。1description : 站点描述可以是你喜欢的一句签名:) 设置 侧边栏社交链接 修改/test目录下的_config.yml文件，设置social字段。 1234social: GitHub: https://github.com/your-user-name || github Twitter: https://twitter.com/your-user-name || twitter Weibo: http://weibo.com/your-user-name || weibo 如果只想显示图标可以设置social_icons字段 1234social_icons: enable: true icons_only: true transition: true 设置「背景动画」 修改/test目录下的_config.yml文件，有4款背景动画，选择你喜欢的设置为true即可1234567891011# Canvas-nestcanvas_nest: true# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false 设置「动画效果」 修改/test目录下的_config.yml文件，设置motion字段。12motion enable: true 选择 Schemenext提供了几种主题模式可供切换，选择一款你喜欢的 /test/themes/next目录下的_config.yml文件，全局查找scheme，选择一款打开注释1234#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 配置 菜单栏 修改/test/themes/next目录下的_config.yml文件，menu关键字下面的配置就是菜单栏，next的默认菜单配置 一般来说我们都会有自己的定制。给出我的配置以供参考 1234567menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive music: /music/ || music || 后面的内容为菜单栏的图标icon，就是Font Awesome 图标名字 配置优化 用户图像 修改/test/themes/next目录下的_config.yml文件，设置avatar 为一张图片，把你喜欢的图片下载并放到 /test/themes/next/source/images文件夹中 1avatar: /images/&lt;图片名字&gt;.jpg 找到主题配置文件：/test/themes/next/source/css/_common/components/sidebar/sidebar-author.styl加入下面代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 添加「标签」页面 在/test/source目录下新建tags文件夹，在/test/source/tags下新建index.md，内容为1234---title: 标签type: &quot;tags&quot;--- 添加「分类」页面 在/test/source目录下新建categories文件夹，在/test/source/categories下新建index.md，内容为1234---title: 标签type: &quot;categories&quot;--- 设置 字体 由于引用国外字体镜像较慢，所以nexT 开放了 5 个特定范围的字体设定来解决问题。修改/test/themes/next目录下的_config.yml文件。找到font关键字，替换它下面的内容为12345678910111213141516171819202122232425262728293031font: enable: true # 外链字体库地址，例如 //fonts.googleapis.com (默认值) host: # 全局字体，应用在 body 元素上 global: external: true family: Monda # 标题字体 (h1, h2, h3, h4, h5, h6) headings: external: true family: Roboto Slab # 文章字体 posts: external: true family: # Logo 字体 logo: external: true family: Lobster Two size: 24 # 代码字体，应用于 code 以及代码块 codes: external: true family: PT Mono 设置代码高亮 修改/test/themes/next目录下的_config.yml文件。修改highlight_theme关键字，共有5款主题供你选择1highlight_theme: normal/night/night blue/night bright/night eighties 设置友情链接 修改/test/themes/next目录下的_config.yml文件。找到Blog rolls进行设置1234567# Blog rollslinks_icon: link （icon图标）links_title: 友情链接 （文字描述）#links_layout: block （设置链接是一行展示一条）links_layout: inline （设置链接是一行展示多条）links: test: http://macshuo.com/ （链接的名字和地址） 设置博客置顶 安装插件 12$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save 设置置顶标志：打开/test/themes/*/layout/_macro/post.swig在&lt;div class=&quot;post-meta&quot;&gt;下方插入代码： 12345&#123;% if post.top %&#125; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=808080&gt;置顶&lt;/font&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125; 然后在需要置顶的文章的Front-matter中加上top即可： 12345---title: 2018date: 2018-10-25 16:10:03top: 100--- 设置和优化打赏 点击进入在线生成二维码生成自己的微信和支付宝二维码。下载下来保存到/test/themes/next/source/images中 修改/test/themes/next目录下的_config.yml文件。找到Reward关键字进行配置 1234-Rewardreward_comment: 谢谢打赏，好人一生平安 （打赏的描述）wechatpay: /images/weixin.png （微信二维码）alipay: /images/zhifubao.png （支付宝二维码） 移除打赏抖动，修改/test/themes/next/source/css/_common/components/post/post-reward.styl，注释以下代码 1234567891011121314151617/* 注释文字闪动函数#wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;#alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;#bitcoin:hover p &#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/ 每篇文章后添加结束标语 新建文件，在/test/themes/next/layout/_macro中新建passage-end-tag.swig文件，添加代码至该文件中： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size: 15px;letter-spacing: 5px;margin-top: 35px;&quot;&gt;----------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-----------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 修改post.swig，打开/test/themes/next/layout/_macro/post.swig文件，在post-body后，post-footer前，添加下面内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改_config，打开/test/themes/next/下的_config.yml，在末尾添加： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 添加转载协议声明 打开/test/themes/next/下的_config.yml，找到Declare license on posts，配置 12345# Declare license on postspost_copyright: enable: true license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/ 打开/test下的_config.yml，找到URL，配置 12# URLurl: &lt;你的github博客地址&gt; 主题优化实现fork me on github 选择样式GitHub Ribbons：https://github.blog/2008-12-19-github-ribbons/ 修改图片跳转链接,将&lt;a href=&quot;https://github.com/you&quot;&gt;中的链接换为自己Github链接 打开/test/themes/next/layout/_layout.swig 文件，把代码复制到&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下面。123&lt;a href=&quot;https://github.com/tmgycsz/tmgycsz.github.io&quot; class=&quot;forkme&quot; target=&quot;_blank&quot;&gt; &lt;img style=&quot;position: absolute; right: 0px;&quot; width=&quot;149&quot; height=&quot;149&quot; src=&quot;https://github.blog/wp-content/uploads/2008/12/forkme_right_white_ffffff.png?resize=149%2C149&quot; class=&quot;attachment-full size-full&quot; alt=&quot;Fork me on GitHub&quot; data-recalc-dims=&quot;1&quot;&gt;&lt;/a&gt; 添加点击爱心效果 在/test/themes/next/source/js/src文件夹下创建clicklove.js，添加代码： 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 在/test/themes/next/layout/_layout.swig文件末尾添加： 123&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clicklove.js&quot;&gt;&lt;/script&gt;` 添加网页崩溃欺骗特效 在/test/themes/next/source/js/src文件夹下创建crash_cheat.js，添加代码： 123456789101112131415&lt;!--崩溃欺骗--&gt; var OriginTitle = document.title; var titleTime; document.addEventListener(&apos;visibilitychange&apos;, function () &#123; if (document.hidden) &#123; document.title = &apos;╭(°A°`)╮ 页面崩溃啦 ~&apos;; clearTimeout(titleTime); &#125; else &#123; document.title = &apos;(ฅ&gt;ω&lt;*ฅ) 噫又好了~&apos; + OriginTitle; titleTime = setTimeout(function () &#123; document.title = OriginTitle; &#125;, 2000); &#125; &#125;); 在/test/themes/next/layout/_layout.swig文件末尾添加： 123&lt;!--崩溃欺骗--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/crash_cheat.js&quot;&gt;&lt;/script&gt;` 添加访问不蒜子统计 打开/test/themes/next/下的_config.yml，找到busuanzi_count，配置12345678busuanzi_count: enable: true total_visitors: true （总的访客人数） total_visitors_icon: user （访客人数图标） total_views: true （总的访问量） total_views_icon: eye （访问量图标） post_views: true （文章总阅读次数） post_views_icon: eye（文章总阅读图标） 添加评论系统Valine 请先注册LeanCloud, 注册成功进入应用列表页面，创建应用。进入刚刚创建的应用，选择左下角的设置&gt;应用Key，然后就能看到你的APP ID和APP Key了。 打开/test/themes/next/下的_config.yml，找到valine，配置12345678910valine: enable: true appid: dHAGLgRYVcYtd02p3WpBLKiQ-gzGzoHsz appkey: DtL0hVwsWFyrDdw4QPWhg9zR notify: false （邮件提醒，回复是否发送到邮箱） verify: false （回复是否需要验证） placeholder: Just go go （回复框占位符） avatar: mm # gravatar style guest_info: nick,mail,link （评论可以填写的信息） pageSize: 10 # （每页显示多少条评论） 添加文章字数统计和预计阅读时间 打开/test/themes/next/下的_config.yml，找到post_wordcount，配置123456post_wordcount item_text: true wordcount: true min2read: true totalcount: true separated_meta: true` 实现本地搜索 /test目录下下载插件 1$ npm install hexo-generator-searchdb --save 修改/test下的_config.yml，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 打开/test/themes/next/下的_config.yml，找到post_wordcount，配置 12345local_search: enable: true trigger: auto （搜索方式：是输入的时候搜索还是回车或搜索键搜索） # show top n results per article, show all results by setting to -1 top_n_per_article: 1 参考文档next文档： http://theme-next.iissnan.com/ 有什么问题欢迎在下方指出 还有其它优化，持续更新中。。。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>next, hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[右键自定义菜单]]></title>
    <url>%2F2019%2F03%2F05%2Fvue%E5%AE%9E%E7%8E%B0%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE%E7%82%B9%E5%87%BB%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[自定义菜单最近的后台管理项目中使用到了右侧标签栏方便用户切换不同模块。但当标签栏过多时一个个关闭明显示是反人类的，所以参考了element admin后写了一个自定义指令来实现点击鼠标右键实现自定义菜单。 最终效果图: 结构代码ui部分html代码： 123456789&lt;div class=&quot;tags_div&quot; v-menus&gt; &lt;el-tag&gt;右键点击&lt;/el-tag&gt; &lt;ul class=&quot;contextmenu&quot; :style=&quot;&#123;&apos;left&apos;: menuLeft, &apos;top&apos;: menuTop&#125;&quot; v-show=&quot;menuShow&quot;&gt; &lt;li&gt;刷新&lt;/li&gt; &lt;li&gt;关闭&lt;/li&gt; &lt;li&gt;关闭其它&lt;/li&gt; &lt;li&gt;关闭所有&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; css代码： 12345678910111213141516171819202122232425262728293031.tags_div &#123; margin-top: 30px; position: relative; display: inline-block; cursor: pointer;&#125;.contextmenu &#123; margin: 0; background: #fff; width: 100px; z-index: 100; position: absolute; list-style-type: none; padding: 5px 0; border-radius: 4px; font-size: 12px; font-weight: 400; color: #333; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, .3)&#125;.contextmenu li &#123; margin: 0; padding: 7px 16px; cursor: pointer;&#125;.contextmenu li:hover &#123; background: #eee;&#125; 这块没什么好说的，主要是设置子相父绝定位，鼠标点击的时候好去设置菜单栏的位置。 自定义指令实现右键菜单栏自定义指令我在上篇已经介绍过了，这里主要说一下设计到的相关事件和属性（上篇自定义拖拽弹窗介绍过的这里不再列出）。 相关属性(事件对象event，dom元素) event.pageX：pageX事件属性返回当事件被触发时鼠标指针向对于html的body的水平坐标。 event.pageY：pageY事件属性返回当事件被触发时鼠标指针向对于html的body垂直坐标。 offsetParent属性：可以返回当前元素上个定位父级元素。 相关事件 oncontextmenu：事件在元素中用户点击鼠标右键时触发。 onmouseup：在用户松开鼠标按键时触发。 实现代码vue代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556directives: &#123; menus: &#123; inserted: function (el, binding, vnode) &#123; //获取vue实例对象 let vm = vnode.context; let showFlag = true; vnode = vnode.elm; //阻止默认浏览器的右键菜单 el.oncontextmenu = ((event) =&gt; &#123; event.preventDefault(); &#125;); el.onmouseup = ((event) =&gt; &#123; if (event.button === 2) &#123; vm.menuShow = true; showFlag = false; let realTop = vm.getElementToPageTop(vnode); let realLeft = vm.getElementToPageLeft(vnode); let top = event.pageY - realTop + 5 + &apos;px&apos;; let left = event.pageX - realLeft + 5 + &apos;px&apos;; vm.menuLeft = left; vm.menuTop = top; &#125; &#125;); document.onmouseup = (() =&gt; &#123; if (showFlag) &#123; vm.menuShow = false; &#125; showFlag = true; &#125;); &#125; &#125;&#125; //vue实例数据data() &#123; return &#123; menuShow: false, menuLeft: 0, menuTop: 0, &#125;&#125;,//获取当前元素距离body原点的距离methods: &#123; getElementToPageTop: function (el) &#123; if (el.offsetParent) &#123; return this.getElementToPageTop(el.offsetParent) + el.offsetTop; &#125; return el.offsetTop; &#125;, getElementToPageLeft: function (el) &#123; if (el.offsetParent) &#123; return this.getElementToPageLeft(el.offsetParent) + el.offsetLeft; &#125; return el.offsetLeft; &#125;&#125; 分析 首先是通过oncontextmenu阻止浏览器的上下文菜单，在绑定onmouseup事件判断鼠标右键点击。 获取当前元素距离body顶端的距离,在与鼠标在页面中的实际距离想减获取鼠标在div中的位置，进而设置菜单栏出现的位置。 给document绑定onmouseup事件，点击页面其他地方关闭菜单栏。 注意点 获取当前元素距离body顶端的距离要判断当前元素有没有上级定位元素，如果有当前元素距离body顶端的距离是它的距离body顶端的距离与定位父级距离body顶端的距离之和。这里我写了两个递归来实现距离的计算getElementToPageTop，getElementToPageLeft。 点击其它的地方关闭菜单栏，这里在自定义指定的元素上点击右键时设置了一个标识，只有当这个标识为false的时候才不会关闭菜单栏。 结语这个方法可以用来实现禁止剪切和复制网页内容…]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义IconFont图标]]></title>
    <url>%2F2019%2F03%2F04%2F%E8%87%AA%E5%AE%9A%E4%B9%89IconFont%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[前言在之前的项目中，很多小的icon图片都是通过利用i标签的特性给它设置固定的宽高和背景来实现的。这种方法在项目大的时候一来需要依赖的图片会很多，二来css代码如果不规范的话也会出现很多问题。所以现在我在新项目中选择了阿里巴巴的矢量图标库来实现自定义IconFont图标。 如何获取图标 首先我们进入阿里巴巴的矢量图标库Iconfont，阿里矢量图标库，注册账号并登录。 在图标管理&gt;我的项目中新建项目。 FontClass/Symbol前缀是用来设置添加到项目中的icon的前缀名。 而Font Family是用来设置字体图标的统一样式的。在后面的详细代码中可以看到具体作用。 在图标库中添加指定的图标到我的项目中 添加选好的图标到购物车 在购物车中添加到指定项目中 进入我的项目 这里有3种格式，Unicode/Font Class/Symbol。其中Unicode图标的描述就是对应的字体编码，而另外两种就是我们新建项目时设置的前缀名加上图标的本身描述。这个可以修改。 点击下载到本地会下载一个压缩包到本地。 修改下载文件解压压缩包。里面会有9个文件，有帮助使用的html本地文件和我们要引入的iconfont.css和iconfont.js文件。 iconfont.css详情 修改iconfont.css，加上下面的代码去设置图标的大小和样式。12345678910[class^=&quot;test-&quot;], [class*=&quot; test-&quot;] &#123;/* 这个字段有可能是`fontFamily`也有可能是`iconfont`，具体与下载下来的`iconfont.css`中保持一致 *//* 第2步`如何获取图标`的`Font Family中设置的是什么就是什么 */ font-family:&quot;iconfont&quot; !important; /* 以下内容参照第三方图标库本身的规则 */ font-size: 18px; font-style:normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125; 使用方式1(v-cli项目中引用)unicode引用 unicode是字体在网页端最原始的应用方式，特点是： 兼容性最好，支持ie6+，及所有现代浏览器。 支持按字体的方式去动态调整图标大小，颜色等等。 但是因为是字体，所以不支持多色。只能使用平台里单色的图标，就算项目里有多色图标也会自动去色。 注意：新版iconfont支持多色图标，这些多色图标在unicode模式下将不能使用，如果有需求建议使用symbol的引用方式 unicode使用步骤如下： 第一步：在v-cli项目main.js中引入iconfont.css。 1import &apos;./assets/icon/iconfont.css&apos;; 第二步：挑选相应图标并获取字体编码，应用于页面 1&lt;i class=&quot;fontFamily&quot;&gt;&amp;#xe6e1;&lt;/i&gt; font-class引用 font-class是unicode使用方式的一种变种，主要是解决unicode书写不直观，语意不明确的问题；与unicode使用方式相比，具有如下特点： 兼容性良好，支持ie8+，及所有现代浏览器。 相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么。 因为使用class来定义图标，所以当要替换图标时，只需要修改class里面的unicode引用。 不过因为本质上还是使用的字体，所以多色图标还是不支持的。 使用步骤如下： 第一步：再v-cli项目main.js中引入iconfont.css。 1import &apos;./assets/icon/iconfont.css&apos;; 第二步：挑选相应图标并获取类名，应用于页面： 1&lt;i class=&quot;el-icon-csz-xxx&quot;&gt;&lt;/i&gt; 注意：这里不用加fontFamily是因为在（2 修改下载文件）中对前缀为el-icon-csz的样式进行了设置。 symbol引用 这是一种全新的使用方式，应该说这才是未来的主流，也是平台目前推荐的用法。这种用法其实是做了一个svg的集合，与另外两种相比具有如下特点： 支持多色图标了，不再受单色限制。 通过一些技巧，支持像字体那样，通过font-size,color来调整样式。 兼容性较差，支持ie9+,及现代浏览器。 浏览器渲染svg的性能一般，还不如png。 使用步骤如下： 第一步：引入项目下面生成的symbol代码： 1import &apos;./assets/icon/iconfont.js&apos;; 第二步：在公用的main.css加入通用css代码： 123456.icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden;&#125; 第三步：挑选相应图标并获取类名，应用于页面： 123&lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt; &lt;use xlink:href=&quot;#el-icon-csz-xxx&quot;&gt;&lt;/use&gt;&lt;/svg&gt; 使用方式2(普通页面使用)压缩包中的demo_index.html文件就是使用方式的帮助文档。可以按照他的教程进行引入。 结语有什么不对的地方欢迎大家评论指出…]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>常用工具之图标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写可拖拽的弹窗]]></title>
    <url>%2F2019%2F03%2F04%2Fvue%E7%BC%96%E5%86%99%E5%8F%AF%E6%8B%96%E6%8B%BD%E7%9A%84%E5%BC%B9%E7%AA%97%2F</url>
    <content type="text"><![CDATA[可拖拽的弹窗 在刚刚重构完的项目中使用到了element ui框架，踩了不少坑也学到了不少的东西。其中比较麻烦的是它的dialog弹窗组件是无法移动拖拽的，然而客户又强烈的要求一定要有这个功能，所以就自己写了个可拖拽的弹窗组件。虽然拖拽起来不是很流畅，但是也算是满足要求了。 实现原理主要的实现原理还是获取鼠标在div中的位置，获取位置后设置div的left和top来达到div跟随鼠标移动的效果。因为写的是vue，所以利用了vue的自定义指令来操作dom。 实现步骤设计盒子ui 老实说，我经常被吐槽没有审美，设计的样式总是被喷。好在这次是dialog弹窗，网上有大把的参考样式。我大体参考了layer的弹窗做出了一个山寨弹窗。 html代码 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div class=&quot;m_showBox&quot; :class=&quot;skin&quot;&gt; &lt;div class=&quot;showBox_mask&quot;&gt;&lt;/div&gt; &lt;div class=&quot;loading_wrap&quot; v-if=&quot;buttonstatus === 1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pop_box&quot; id=&quot;pox-box&quot; v-drag&gt; &lt;p class=&quot;pop_box_title&quot;&gt; &#123;&#123;title || &quot;提示&quot;&#125;&#125; &lt;span class=&quot;pop_box_close&quot; @click=&quot;cancel&quot;&gt;&lt;/span&gt; &lt;/p&gt; &lt;div class=&quot;pop_box_content&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class=&quot;pop_box_bottom&quot;&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;cancel_btn&quot; @click=&quot;cancel&quot;&gt;&#123;&#123;canceltext || &quot;取消&quot;&#125;&#125;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;confirm_btn&quot; v-if=&quot;type === &apos;confirm&apos;&quot; :class=&quot;&#123;widths: buttonstatus === 1&#125;&quot; @click=&quot;confirm&quot;&gt; &lt;svg viewBox=&quot;25 25 50 50&quot; class=&quot;u-circular&quot; v-if=&quot;buttonstatus === 1&quot;&gt; &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;20&quot; fill=&quot;none&quot; class=&quot;path&quot;&gt;&lt;/circle&gt; &lt;/svg&gt; &lt;span :class=&quot;&#123;&apos;marginLeft&apos;: buttonstatus === 1&#125;&quot;&gt;&#123;&#123;confirmtext || &apos;确定&apos;&#125;&#125;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; css代码太长放到github上了[vueDrag.vue][1] 效果图： 设计要点: 背景遮罩我这里选择了使用了3个遮罩板，第一块是覆盖全屏幕的白色遮罩m_showBox使用fixed定位，让弹窗的所有内容与浏览器之间不会出现留白。第2块就是上图看到的灰色背景showBox_mask，用来突显弹窗。最后一块是点击确定的遮罩窗loading_wrap，来防止提交ajax时，用户点击按钮或修改弹窗数据。 弹窗构成这里的弹窗就包括标题，内容和底部部分。内容部分通过插槽插入内容，底部按钮通过svg来实现提交加载的loading效果。 定义组件props通过传入的props值来设置弹窗的样式和文案。 自定义事件实现按钮回调confirm和cancel自定义事件，定义自定义按钮事件，使用$emit触发。1234567891011methods: &#123; cancel: function () &#123; this.$emit(&quot;cancel&quot;); &#125;, confirm: function () &#123; if (this.buttonstatus === 1) &#123; return; &#125; this.$emit(&quot;confirm&quot;); &#125;, &#125;, 自定义指令drag实现拖拽效果vue的directives。通过vue自定义指令获取绑定的元素，在对DOM进行操作。关于更多vue自定义指令用法，移步自定义指令 相关属性(事件对象event，dom元素，window对象)。 event.clientX：clientX事件属性返回当事件被触发时鼠标指针向对于浏览器可视区域的水平坐标。 event.clientY：clientY事件属性返回当事件被触发时鼠标指针向对于浏览器页面可视区域的垂直坐标。 offsetLeft/offsetLeftTop属性：可以返回当前元素距离某个定位父辈元素左边与顶部的距离（虽然我的父级遮罩层有了定位，但是它的宽高都是与body保持一致的）。 offsetWidth/offsetHeight: 返回任何一个元素宽/高度，包括边框和填充 window.innerHeight/Width: 获取当前页面可视区的宽高（包括滚动条）。 相关事件 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748directives: &#123; drag: &#123; inserted: function (el, binding, vnode) &#123; vnode = vnode.elm; el.onmousedown = ((event) =&gt; &#123; if (event.target.className !== "pop_box_title") &#123; return; &#125; //获取鼠标在盒子中的位置 let mouseX = event.clientX - vnode.offsetLeft; let mouseY = event.clientY - vnode.offsetTop; //绑定移动和停止函数 document.onmousemove = ((event) =&gt; &#123; let left, top; //获取新的鼠标位置对应下的盒子应该在的位置 left = event.clientX - mouseX; top = event.clientY - mouseY; //获取div在页面中X轴的最小最大位置 let minX = vnode.offsetWidth / 2; let maxX = (window.innerWidth - vnode.offsetWidth / 2) - 10//去掉滚动条的宽度 if (left &lt;= minX) &#123; left = minX; &#125; else if (left &gt;= maxX) &#123; left = maxX; &#125; //获取div在页面中Y轴的最大最小位置 let minY = vnode.offsetHeight / 2; let maxY = (window.innerHeight - vnode.offsetHeight / 2); if (top &lt;= minY) &#123; top = minY; &#125; else if (top &gt;= maxY) &#123; top = maxY; &#125; //赋值移动 vnode.style.left = left + 'px'; vnode.style.top = top + 'px'; &#125;); document.onmouseup = (() =&gt; &#123; document.onmousemove = document.onmouseup = null; &#125;); &#125;); window.onresize = (() =&gt;&#123; vnode.style.left = "50%"; vnode.style.top = "50%"; &#125;); &#125; &#125;&#125; 代码解析 给弹窗绑定onmousedown事件，获取到鼠标在弹窗中的位置（以弹窗左上角为原点）。 document绑定onmousemove事件，获取当前的鼠标位置，当前鼠标位置减去鼠标在弹窗的相当位置即可得到此时弹窗应该处于的位置。然后在通过style设置弹窗的位置。 鼠标松开解绑document的鼠标事件。 注意点： 弹窗要一直在页面可视区移动，最大的移动距离就是可视区的宽高减去盒子本身的宽高(还要考虑到浏览器的滚动条的宽高，我的浏览器滚动条是自己设置的，高度为0，宽度为10)。window.innerHeight - vnode.offsetHeight / 2;(window.innerWidth - vnode.offsetWidth / 2) - 10; 只有弹窗标题才能拖拽，所以判断非标题部分之间return。 浏览器窗口大小改变会影响弹窗的位置，监听改变浏览器窗口改变把弹窗居中。 使用单独引用 下载drag.vue。vueDrag.vue。 控制弹窗的显示隐藏通过v-if绑定data里的数据即可。 123456789101112&lt;transition name="el-fade-in"&gt; &lt;v-drag v-if="isShow" :tilte="title" :type="type" @confirm="confirmSubmit" @cancel="cancel" :buttonstatus="buttonstatus"&gt; &lt;el-form label-width="100px"&gt; &lt;el-form-item label="用户名称："&gt; &lt;el-input placeholder="请输入用户名" v-model="username"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="密码："&gt; &lt;el-input placeholder="请输入密码" v-model="password"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/v-drag&gt; &lt;/transition&gt; 相关的属性和emit方法需要自己定义 v-cli全局引入 src目录下新建components目录，下载vueDrag.vue到此目录下。 components目录下新建index.js 12345import VueDrag form ./vueDrag.vueexport default function install(Vue) &#123; Vue.component(&quot;app-drag&quot;, VueDrag);&#125; main.js中加入代码 12import appComponents from &quot;./components/index.js&quot;;Vue.use(appComponents); 页面中使用&lt;app-drag&gt;&lt;/app-drag&gt; 结语关于这个组件我觉得还有很多优化的地方，望各位大佬给出意见。]]></content>
      <categories>
        <category>vue组件</category>
      </categories>
      <tags>
        <tag>vue组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1hexo new page More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hello</category>
      </categories>
      <tags>
        <tag>hello</tag>
      </tags>
  </entry>
</search>
