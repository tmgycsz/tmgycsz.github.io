<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[自定义IconFont图标]]></title>
    <url>%2F2019%2F03%2F04%2F%E8%87%AA%E5%AE%9A%E4%B9%89IconFont%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[前言在之前的项目中，很多小的icon图片都是通过利用i标签的特性给它设置固定的宽高和背景来实现的。这种方法在项目大的时候一来需要依赖的图片会很多，二来css代码如果不规范的话也会出现很多问题。所以现在我在新项目中选择了阿里巴巴的矢量图标库来实现自定义IconFont 图标。 如何获取图标 首先我们进入阿里巴巴的矢量图标库Iconfont，阿里矢量图标库，注册账号并登录。 在【图标管理&gt;我的项目】中新建项目。 FontClass/Symbol 前缀是用来设置添加到项目中的icon的前缀名。而Font Family是用来设置字体图标的统一样式的。在后面的详细代码中可以看到具体作用。 在图标库中添加指定的图标到我的项目中 添加选好的图标到购物车 在购物车中添加到指定项目中 进入我的项目 这里有3种格式，Unicode/Font Class/Symbol。其中Unicode图标的描述就是对应的字体编码，而另外两种就是我们新建项目时设置的前缀名加上图标的本身描述。这个可以修改。 点击下载会下载一个压缩包到本地。 修改下载文件解压压缩包。里面会有9个文件，有帮助使用的html本地文件和我们要引入的iconfont.css和iconfont.js文件。 iconfont.css详情 修改iconfont.css，加上下面的代码去设置图标的大小和样式。123456789[class^=&quot;el-icon-csz&quot;], [class*=&quot; el-icon-csz&quot;] &#123;/* 这个字段有可能是fontFamily也有可能是iconfont，具体与下载下来的iconfont.css中保持一致 */ font-family:&quot;fontFamily&quot; !important; /* 以下内容参照第三方图标库本身的规则 */ font-size: 18px; font-style:normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125; 使用方式1(v-cli项目中引用)unicode引用 unicode是字体在网页端最原始的应用方式，特点是： 兼容性最好，支持ie6+，及所有现代浏览器。 支持按字体的方式去动态调整图标大小，颜色等等。 但是因为是字体，所以不支持多色。只能使用平台里单色的图标，就算项目里有多色图标也会自动去色。 注意：新版iconfont支持多色图标，这些多色图标在unicode模式下将不能使用，如果有需求建议使用symbol的引用方式 unicode使用步骤如下： 第一步：在v-cli项目main.js中引入iconfont.css。 1import &apos;./assets/icon/iconfont.css&apos;; 第二步：挑选相应图标并获取字体编码，应用于页面 1&lt;i class=&quot;fontFamily&quot;&gt;&amp;#xe6e1;&lt;/i&gt; font-class引用 font-class是unicode使用方式的一种变种，主要是解决unicode书写不直观，语意不明确的问题；与unicode使用方式相比，具有如下特点： 兼容性良好，支持ie8+，及所有现代浏览器。 相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么。 因为使用class来定义图标，所以当要替换图标时，只需要修改class里面的unicode引用。 不过因为本质上还是使用的字体，所以多色图标还是不支持的。 使用步骤如下： 第一步：再v-cli项目main.js中引入iconfont.css。 1import &apos;./assets/icon/iconfont.css&apos;; 第二步：挑选相应图标并获取类名，应用于页面： 1&lt;i class=&quot;el-icon-csz-xxx&quot;&gt;&lt;/i&gt; 注意：这里不用加fontFamily是因为在（2 修改下载文件）中对前缀为el-icon-csz的样式进行了设置。 symbol引用 这是一种全新的使用方式，应该说这才是未来的主流，也是平台目前推荐的用法。相关介绍可以参考这篇文章 这种用法其实是做了一个svg的集合，与另外两种相比具有如下特点： 支持多色图标了，不再受单色限制。 通过一些技巧，支持像字体那样，通过font-size,color来调整样式。 兼容性较差，支持 ie9+,及现代浏览器。 浏览器渲染svg的性能一般，还不如png。 使用步骤如下： 第一步：引入项目下面生成的symbol代码： 1import &apos;./assets/icon/iconfont.js&apos;; 第二步：在公用的main.css加入通用css代码： 123456.icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden;&#125; 第三步：挑选相应图标并获取类名，应用于页面： 123&lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt; &lt;use xlink:href=&quot;#el-icon-csz-xxx&quot;&gt;&lt;/use&gt;&lt;/svg&gt; 使用方式2(普通页面使用)压缩包中的demo_index.html文件就是使用方式的帮助文档。可以按照他的教程进行引入。 结语有什么不对的地方欢迎大家评论指出…]]></content>
      <categories>
        <category>常用工具</category>
      </categories>
      <tags>
        <tag>常用工具之图标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写可拖拽的弹窗]]></title>
    <url>%2F2019%2F03%2F04%2F%E7%BC%96%E5%86%99%E5%8F%AF%E6%8B%96%E6%8B%BD%E7%9A%84%E5%BC%B9%E7%AA%97%2F</url>
    <content type="text"><![CDATA[可拖拽的弹窗 在刚刚重构完的项目中使用到了element ui框架，踩了不少坑也学到了不少的东西。其中比较麻烦的是它的dialog弹窗组件是无法移动拖拽的，然而客户又强烈的要求一定要有这个功能，所以就自己写了个可拖拽的弹窗组件。虽然拖拽起来不是很流畅，但是也算是满足要求了。 实现原理主要的实现原理还是获取鼠标在div中的位置，获取位置后设置div的left和top来达到div跟随鼠标移动的效果。因为写的是vue，所以利用了vue的自定义指令来操作dom。 实现步骤设计盒子ui 老实说，我经常被吐槽没有审美，设计的样式总是被喷。好在这次是dialog弹窗，网上有大把的参考样式。我大体参考了layer的弹窗做出了一个山寨弹窗。 html代码 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div class=&quot;m_showBox&quot; :class=&quot;skin&quot;&gt; &lt;div class=&quot;showBox_mask&quot;&gt;&lt;/div&gt; &lt;div class=&quot;loading_wrap&quot; v-if=&quot;buttonstatus === 1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pop_box&quot; id=&quot;pox-box&quot; v-drag&gt; &lt;p class=&quot;pop_box_title&quot;&gt; &#123;&#123;title || &quot;提示&quot;&#125;&#125; &lt;span class=&quot;pop_box_close&quot; @click=&quot;cancel&quot;&gt;&lt;/span&gt; &lt;/p&gt; &lt;div class=&quot;pop_box_content&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class=&quot;pop_box_bottom&quot;&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;cancel_btn&quot; @click=&quot;cancel&quot;&gt;&#123;&#123;canceltext || &quot;取消&quot;&#125;&#125;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;confirm_btn&quot; v-if=&quot;type === &apos;confirm&apos;&quot; :class=&quot;&#123;widths: buttonstatus === 1&#125;&quot; @click=&quot;confirm&quot;&gt; &lt;svg viewBox=&quot;25 25 50 50&quot; class=&quot;u-circular&quot; v-if=&quot;buttonstatus === 1&quot;&gt; &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;20&quot; fill=&quot;none&quot; class=&quot;path&quot;&gt;&lt;/circle&gt; &lt;/svg&gt; &lt;span :class=&quot;&#123;&apos;marginLeft&apos;: buttonstatus === 1&#125;&quot;&gt;&#123;&#123;confirmtext || &apos;确定&apos;&#125;&#125;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; css代码太长放到github上了vueDrag.vue 效果图： 设计要点: 背景遮罩我这里选择了使用了3个遮罩板，第一块是覆盖全屏幕的白色遮罩（m_showBox）使用fixed定位，让弹窗的所有内容与浏览器之间不会出现留白。第2块就是上图看到的灰色背景（showBox_mask），用来突显弹窗。最后一块是点击确定的遮罩窗（loading_wrap），来防止提交ajax时，用户点击按钮或修改弹窗数据。 弹窗构成这里的弹窗就包括标题，内容和底部部分。内容部分通过插槽插入内容，底部按钮通过svg来实现提交加载的loading效果。 定义组件props通过传入的props值来设置弹窗的样式和文案。 自定义事件实现按钮回调confirm和cancel自定义事件，定义自定义按钮事件，使用$emit触发。1234567891011methods: &#123; cancel: function () &#123; this.$emit(&quot;cancel&quot;); &#125;, confirm: function () &#123; if (this.buttonstatus === 1) &#123; return; &#125; this.$emit(&quot;confirm&quot;); &#125;, &#125;, 自定义指令drag实现拖拽效果vue的directives。通过vue自定义指令获取绑定的元素，在对DOM进行操作。关于更多vue自定义指令用法，移步自定义指令 相关属性(事件对象event，dom元素，window对象)。 event.clientX：clientX事件属性返回当事件被触发时鼠标指针向对于浏览器可视区域的水平坐标。 event.clientY：clientY事件属性返回当事件被触发时鼠标指针向对于浏览器页面可视区域的垂直坐标。 offsetLeft/offsetLeftTop属性：可以返回当前元素距离某个定位父辈元素左边与顶部的距离（虽然我的父级遮罩层有了定位，但是它的宽高都是与body保持一致的）。 offsetWidth/offsetHeight: 返回任何一个元素宽/高度，包括边框和填充 window.innerHeight/Width: 获取当前页面可视区的宽高（包括滚动条）。 相关事件 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748directives: &#123; drag: &#123; inserted: function (el, binding, vnode) &#123; vnode = vnode.elm; el.onmousedown = ((event) =&gt; &#123; if (event.target.className !== "pop_box_title") &#123; return; &#125; //获取鼠标在盒子中的位置 let mouseX = event.clientX - vnode.offsetLeft; let mouseY = event.clientY - vnode.offsetTop; //绑定移动和停止函数 document.onmousemove = ((event) =&gt; &#123; let left, top; //获取新的鼠标位置对应下的盒子应该在的位置 left = event.clientX - mouseX; top = event.clientY - mouseY; //获取div在页面中X轴的最小最大位置 let minX = vnode.offsetWidth / 2; let maxX = (window.innerWidth - vnode.offsetWidth / 2) - 10//去掉滚动条的宽度 if (left &lt;= minX) &#123; left = minX; &#125; else if (left &gt;= maxX) &#123; left = maxX; &#125; //获取div在页面中Y轴的最大最小位置 let minY = vnode.offsetHeight / 2; let maxY = (window.innerHeight - vnode.offsetHeight / 2); if (top &lt;= minY) &#123; top = minY; &#125; else if (top &gt;= maxY) &#123; top = maxY; &#125; //赋值移动 vnode.style.left = left + 'px'; vnode.style.top = top + 'px'; &#125;); document.onmouseup = (() =&gt; &#123; document.onmousemove = document.onmouseup = null; &#125;); &#125;); window.onresize = (() =&gt;&#123; vnode.style.left = "50%"; vnode.style.top = "50%"; &#125;); &#125; &#125;&#125; 代码解析 给弹窗绑定onmousedown事件，获取到鼠标在弹窗中的位置（以弹窗左上角为原点）。 document绑定onmousemove事件，获取当前的鼠标位置，当前鼠标位置减去鼠标在弹窗的相当位置即可得到此时弹窗应该处于的位置。然后在通过style设置弹窗的位置。 鼠标松开解绑document的鼠标事件。 注意点： 弹窗要一直在页面可视区移动，最大的移动距离就是可视区的宽高减去盒子本身的宽高(还要考虑到浏览器的滚动条的宽高，我的浏览器滚动条是自己设置的，高度为0，宽度为10)。window.innerHeight - vnode.offsetHeight / 2;(window.innerWidth - vnode.offsetWidth / 2) - 10; 只有弹窗标题才能拖拽，所以判断非标题部分之间return。 浏览器窗口大小改变会影响弹窗的位置，监听改变浏览器窗口改变把弹窗居中。 使用 下载drag.vue。vueDrag.vue。 使用import引入 1import vDrag from "./dragDiv.vue" 控制弹窗的显示隐藏通过v-if绑定data里的数据即可。 123456789101112&lt;transition name="el-fade-in"&gt; &lt;v-drag v-if="isShow" :tilte="title" :type="type" @confirm="confirmSubmit" @cancel="cancel" :buttonstatus="buttonstatus"&gt; &lt;el-form label-width="100px"&gt; &lt;el-form-item label="用户名称："&gt; &lt;el-input placeholder="请输入用户名" v-model="username"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="密码："&gt; &lt;el-input placeholder="请输入密码" v-model="password"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/v-drag&gt; &lt;/transition&gt; 结语关于这个组件我觉得还有很多优化的地方，望各位大佬给出意见。]]></content>
      <categories>
        <category>vue组件</category>
      </categories>
      <tags>
        <tag>vue组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1hexo new page More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hello</category>
      </categories>
      <tags>
        <tag>hello</tag>
      </tags>
  </entry>
</search>
